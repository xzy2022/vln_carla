# 车辆物理控制（UE5）

本文档说明 CARLA UE5 中常见车辆控制接口的使用方式、控制效果，以及“哪些车型参数会影响控制结果”。

参考文档：
- `Docs_Carla_UE5/python_api.md`
- `Docs_Carla_UE5/core_actors.md`
- `Docs_Carla_UE5/tuto_G_control_vehicle_physics.md`

## 控制接口总览

| 控制方式 | 典型接口 | 输入空间 | 结果特征 | 适用场景 |
|---|---|---|---|---|
| 驾驶输入控制 | `Vehicle.apply_control(VehicleControl)` | 油门/转向/刹车（归一化） | 物理真实，受车型动力学影响显著 | 自动驾驶决策、真实驾驶仿真 |
| Ackermann 控制 | `Vehicle.apply_ackermann_control(VehicleAckermannControl)` | 转角(rad)、转角速度、速度、加速度、jerk | 更接近车辆运动学目标，仍受物理约束 | 路径跟踪、平滑速度控制 |
| 直接速度/角速度控制 | `Actor.set_target_velocity`、`Actor.set_target_angular_velocity`、`Actor.enable_constant_velocity` | 速度向量/角速度向量 | 更“强制”地写入状态，仍会被外界力影响 | 轨迹回放、基准测试、强跟踪 |
| 物理参数重配置 | `Vehicle.apply_physics_control` | 发动机、传动、底盘、轮胎、悬架参数 | 不直接驱动车辆；改变“车辆本体”动力学 | 车型标定、域随机化、对照实验 |

## 1) VehicleControl：油门/转向/刹车

主要接口：
- `carla.VehicleControl(throttle, steer, brake, hand_brake, reverse, manual_gear_shift, gear)`
- `vehicle.apply_control(control)`

关键范围：
- `throttle` `[0, 1]`
- `steer` `[-1, 1]`
- `brake` `[0, 1]`

效果说明：
- `throttle` 是驱动请求，不是直接速度；
- `steer` 是归一化转向请求，不是直接前轮角度；
- `brake` 是制动请求，不是直接制动力矩。

会影响其结果的车型参数：
- 动力总成：`torque_curve`、`max_torque`、`max_rpm`、`forward_gear_ratios`、`final_ratio`、`differential_type`
- 车身参数：`mass`、`drag_coefficient`、`center_of_mass`
- 转向相关：`steering_curve`、轮胎 `max_steer_angle`
- 制动相关：轮胎 `max_brake_torque`、`max_handbrake_torque`
- 抓地/稳定性：`cornering_stiffness`、`friction_force_multiplier`、悬架参数

结论：
- 这是“最物理真实”的控制层，车型差异影响最大。

## 2) Ackermann：运动学目标控制

主要接口：
- `carla.VehicleAckermannControl(steer, steer_speed, speed, acceleration, jerk)`
- `vehicle.apply_ackermann_control(control)`
- `vehicle.apply_ackermann_controller_settings(settings)`（PID 等设置）

效果说明：
- 可直接给目标速度、目标转角、加速度与 jerk；
- 比 `VehicleControl` 更接近“轨迹跟踪控制器”的输入形式；
- 仍在物理仿真中执行，不是脱离物理约束的硬设定。

会影响其结果的车型参数：
- 与 `VehicleControl` 基本一致（动力、车身、轮胎、悬架参数）；
- 尤其受 `steering_curve` 与 `max_steer_angle` 影响（高速度下可达转向幅度）；
- 受 `mass`、`drag_coefficient`、驱动参数影响速度跟踪误差。

结论：
- Ackermann 是“更高层”的驾驶目标，不等于无视车型动力学。

## 3) 直接速度/角速度控制

主要接口：
- `actor.set_target_velocity(Vector3D)`  
- `actor.set_target_angular_velocity(Vector3D)`  
- `actor.enable_constant_velocity(Vector3D)` / `disable_constant_velocity()`

效果说明：
- 这类接口在 physics step 前写入目标速度状态，控制更直接；
- 但 physics step 后仍会受到外力（摩擦、碰撞、坡度等）影响；
- `enable_constant_velocity` 持续施加速度目标，通常比单次设置更“强跟踪”。

会影响其结果的车型参数：
- 相比 `VehicleControl/Ackermann`，发动机与传动参数影响会弱化；
- 轮胎摩擦、碰撞、阻力、重力等外界与底盘相关因素仍影响最终速度；
- 若持续每帧设定目标速度，可在一定程度上压过动力总成差异。

结论：
- 适合“强制速度跟踪/轨迹回放”；不适合评估真实驾驶性能上限。

## 4) 物理参数重配置（VehiclePhysicsControl / WheelPhysicsControl）

主要接口：
- `physics = vehicle.get_physics_control()`
- 修改 `physics` 与 `physics.wheels[i]` 参数
- `vehicle.apply_physics_control(physics)`

效果说明：
- 不是直接控制车辆当前速度/转角；
- 是改变车辆的动力学本体，进而影响所有上层控制方法的效果。

与其他控制方式的关系：
- `VehicleControl`、`Ackermann`、`set_target_velocity` 的最终表现都会受这些参数影响；
- 用于统一不同车型表现（标定）或拉开差异（对照实验）。

## 5) 选型建议

1. 需要真实驾驶行为评估：优先 `VehicleControl`。  
2. 需要路径/速度平滑跟踪：优先 `Ackermann`。  
3. 需要强制速度或轨迹复现：用 `set_target_velocity` / `enable_constant_velocity`。  
4. 需要跨车型一致性：先做 `VehiclePhysicsControl` 标定，再比较控制器。  

## 6) 物理状态与上帝真值获取（UE5）

在调试控制效果时，建议每帧同时记录“控制输入 + 真值状态”。  
CARLA UE5 中可直接获取如下真值：

- 自车状态（单车）：
  - `vehicle.get_location()`
  - `vehicle.get_transform()`
  - `vehicle.get_velocity()`
  - `vehicle.get_acceleration()`
  - `vehicle.get_angular_velocity()`
- 全局状态（全场 Actor）：
  - `world.wait_for_tick()` / `world.on_tick(...)` 获取 `carla.WorldSnapshot`
  - `actor_snapshot.get_transform() / get_velocity() / get_acceleration() / get_angular_velocity()`

注意：
- 上述 getter 返回的是“上一 tick 客户端接收的数据”，文档说明这些方法本身不额外调用模拟器；
- `WorldSnapshot` 适合做多车同帧对齐分析（同一帧内对所有 actor 一致采样）；
- 速度向量单位为 `m/s`，可用 `sqrt(vx^2 + vy^2 + vz^2)` 换算标量车速。

示例（单车真值采集）：

```python
import math

def read_vehicle_truth(vehicle):
    t = vehicle.get_transform()
    v = vehicle.get_velocity()
    a = vehicle.get_acceleration()
    w = vehicle.get_angular_velocity()

    speed_mps = math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
    speed_kph = speed_mps * 3.6

    return {
        "location": t.location,
        "rotation": t.rotation,
        "velocity": v,
        "acceleration": a,
        "angular_velocity": w,
        "speed_mps": speed_mps,
        "speed_kph": speed_kph,
    }
```

示例（多车同帧真值采集）：

```python
snapshot = world.wait_for_tick()
frame = snapshot.frame
ts = snapshot.timestamp.elapsed_seconds

for actor_snapshot in snapshot:
    actor = world.get_actor(actor_snapshot.id)
    if actor is None:
        continue
    if "vehicle." not in actor.type_id:
        continue

    tr = actor_snapshot.get_transform()
    vel = actor_snapshot.get_velocity()
    acc = actor_snapshot.get_acceleration()
    ang = actor_snapshot.get_angular_velocity()

    # 在同一 frame 下记录多车真值
    print(frame, ts, actor.id, actor.type_id, tr.location, vel, acc, ang)
```
